# Book-ThenZenOfDesignPatterns
《设计模式之禅》阅读笔记及练习代码


# 六大设计原则

- 单一职责原则：应该有且仅有一个原因引起类的变更。
- 里氏替换原则：父类能出现的地方，子类就能出现。
- 依赖倒置原则：高层通过依赖低层的接口实现依赖关系，低层依赖接口并实现细节。
- 接口隔离原则：接口应该尽量细化，接口中的方法应该尽量少。
- 迪米特法则：最少知识原则（LKP）。一个对象应该对其他对象尽量少的了解，不需要了解调用的类的内部。
- 开闭原则：对扩展开放，对修改关闭。

### 单一职责原则 SRP
一个接口应该只包含一个职责，有点是：
- 类的复杂性降低
- 代码可读性提高
- 代码可维护性提高
- 变更时引起的风险降低

主要是用在接口设计上，但也可以用在类上和方法上。不过在实际中很难完全符合单一职责原则，因为职责是比较难以界定的，而且还有其他因素的影响，诸如工期、成本等等。

最佳实践：接口尽量做到单一职责原则，类的设计尽量做到只有一个原因引起变化。

### 里氏替换原则 LSP
父类能出现的地方，子类就能出现。
- 子类必需完全实现父类的方法，如果不能完整的实现父类的方法，应该断开父子关系，采用依赖、聚集、组合等方式代替继承。
- 子类可以有自己的方法和属性
- 子类覆盖或者实现父类方法时，参数可以被放大，不能缩小。
- 子类覆盖或者实现父类方法时，输出可以被缩小，不能放大。

最佳实践：尽量避免子类的“个性”，把子类当父类用。

### 依赖倒置原则 DIP
面向接口编程的精髓之一
定义：（抽象在 Java 中指的就是接口和抽象类）
- 高层模块不依赖低层模块，都依赖低层模块的抽象（模块间不直接依赖，依赖关系通过接口产生）
- 抽象不依赖细节，由细节依赖抽象（接口不依赖实现类，实现类依赖接口）
依赖的三种写法：构造函数注入，Setter 方法注入，接口注入（方法声明上传参数）
特点：难以实现，小项目体现不出优点，是实现开闭原则的主要途径。

最佳实践：
- 没个类尽量有接口或抽象类
- 变量类型尽量是接口
- 类不应该从具体类派生（尽量）
- 尽量不覆写基类的方法
- 结合里氏替换原则使用

### 接口隔离原则
接口应该尽量细化，接口中的方法应该尽量少
与单一原则的区别：单一原则注重职责，业务逻辑。接口隔离要求接口中方法少。对外开放的接口，即使符合单一原则，也应该尽量在不同的接口中定义。
- 接口要尽量小，但不能违反单一原则
- 接口要高内聚
- 接口只提供需要的方法
- 接口设计是有限度的，不能过度设计

最佳实践：
- 一个接口只服务于一个子模块或业务逻辑
- 减少 public 方法，经常回顾是否提供了一堆 public 方法
- 如果一个接口出现问题，尽量改，如果修改风险大，则使用适配器模式转化
- 了解环境和业务逻辑，不盲目进行设计

### 迪米特法则 LoD
AKA 最少知识原则（LKP）。一个对象应该对其他对象尽量少的了解，不需要了解调用的类的内部。
朋友类定义：出现在方法的输入输出参数中、类的成员变量中的类。
- 只和朋友类交流
- 朋友类间是有距离的，一个类公开的方法属性阅读，修改时的风险就越大
- 自己的就是自己的，一个方法放到哪个类都可以的时候，原则：一个方法放到本类中不增加类间关系，不对本类产生负面影响，就放到本类中。
- 谨慎使用 Serializable。远程调用时，一方修改可能会出问题。

最佳实践：核心观念，类间低耦合。
导致大量中间类，导致复杂度变高。需要权衡，是结构清晰，还是高内聚低耦合。

### 开闭原则
对扩展开放，对修改关闭。
尽量不修改接口，也不修改实现类，通过扩展新类来实现功能变更。
- 逻辑变化：关联和依赖的逻辑同步修改，可以修改类中原有方法。
- 子模块变化：低层次模块变化必然引起高层模块变化，通过扩展完成变化，高层次模块也必需修改。
- 可见视图变化：提供给用户的界面需要作出较大改变，可以通过扩展来实现。

# 设计模式
- 单例模式
- 工厂方法模式
- 抽象工厂模式


### 单例模式
一个类，有且仅有一个实例。

### 工厂方法模式
#### 通用方式：
1. 定义产品接口，和数个产品实现类。
2. 定义一个AbstractFactory，和其实现类。
#### 工厂方法的有点：
1. 封装性好，调用者只需要类名（或 key 等），不需要知道创建类的过程
2. 扩展性好，适当修改就可以添加新产品。
3. 屏蔽产品类，产品类的实现如果变化，调用者不用关心。
4. 典型解耦框架，高层模块需要知道抽象类，实现类不关心。符合迪米特、依赖倒置、里氏替换原则。
#### 简单工厂方法：
1. 定义产品接口，和数个产品实现类。
2. 定义Factory类，内部方法是静态方法。
#### 多个工厂方法：
1. 定义产品接口，和数个产品实现类。
2. 定义一个AbstractFactory，对每个产品实现一个工厂实现类，有具体工厂实现类实例产品。
#### 其他：
1. 替换单例模式
2. 延迟初始化：在 map 中缓存之前创建的实例

### 抽象工厂模式
工厂方法模式的升级版，工厂方法模式针对的是一个产品等级结构；而抽象工厂模式则是针对的多个产品等级结构。
例：

- 工厂方法：生产玩具，红色玩具、蓝色玩具。玩具是抽象类，红色、蓝色都是实现类。
- 抽象工厂模式：生产玩具，红色塑料玩具、红色金属玩具，蓝色塑料玩具、蓝色金属玩具。
    - 红色、蓝色都是抽象类
    - 一个抽象类AbstractFactory，有多个方法，每个方法生产对应的颜色。
    - 有多个实现类，塑料玩具实现类，金属玩具实现类。
##### 优点：
工厂方法的优点，产品族内可以有约束。产品族：红色玩具是一族、蓝色玩具是一族。
##### 缺点：
扩展性差